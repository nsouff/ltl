\documentclass[12pt,a4paper]{article}

\usepackage[french]{babel}
\usepackage[T1]{fontenc}

% Formules mathématiques
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{mathrsfs}

\usepackage{tikz}



% quelques définitions
\theoremstyle{plain}
\newtheorem{thm}{Théorème}
\newtheorem{cor}[thm]{Corollaire}
\newtheorem{lem}[thm]{Lemme}
\newtheorem{prop}{Proposition}
\newtheorem{dem}{Démonstration}

\theoremstyle{definition}
\newtheorem{defi}{Définition}
\newtheorem{rmq}{Remarque}
\newtheorem{ex}{Exemple}

% Dessiner les automates
\usepackage{tikz}
\usetikzlibrary{automata, positioning, arrows}

% Plus d'options sur les listes de type 'enumerate'
\usepackage{enumerate} 


\title {Automates et logique temporelle LTL}
\author{
  Souffan Nathan \and
  Bouarah Romain \and
  \\Supervisé par François Laroussinie
}


\begin{document}
\maketitle
\newpage

\section{Logique temporelle}

Si pour la logique une propriété ne peut être que vrai ou fausse, celle ci peut être vrai à un certain moment puis fausse par la suite en logique temporelle. On peut considérer plusieurs espace temps. On peut prendre le temps comme étant $\mathbb{R}$, $\mathbb{Z}$ ou encore comme ce sera le cas par la suite $\mathbb{N}$. Celle ci s'appelle la logique \underline{LTL} (Logique Temporelle Linéaire).

\subsection{LTL}
On se place donc dans le cas d'une logique temporelle linéaire, On défini $AP$ l'ensemble des propositions atomiques. Il y a alors une valuation des $AP$ pour chaque $n$ dans $\mathbb{N}$.

\subsubsection{Syntaxe}
On définit l'ensemble des formules propositionnelles comme l'ensemble engendré inductivement et librement par les règles de constructions suivantes:
\begin{itemize}
	\item[] \textbf{atomes} Si $p \in AP$ alors $p$ est une formule propositionnelle.
	\item[] \textbf{absurde} $\bot$ est une formule propositionnelle.
	\item[] \textbf{Négation} Si $\varphi$ est une formule propositionnelle, $\lnot \varphi$ en est aussi une.
	\item[] \textbf{Conjonction} Si $\varphi$ et $\psi$ sont des formules propositionnelles, $(\varphi\land \psi)$ est une formule propositionnelle.
	\item[] \textbf{Disjonction} Si $\varphi$ et $\psi$ sont des formules propositionnelles, $(\varphi\lor \psi)$ est une formule propositionnelle.
	\item[] \textbf{Implication} Si $\varphi$ et $\psi$ sont des formules propositionnelles, $(\varphi \to \psi)$ est une formule propositionnelle.
	\item[] \textbf{Suivant (next)} Si $\varphi$ est une formule propositionnelle, $X\varphi$ est une formule propositionnelle.
	\item[] \textbf{Jusqu'à (Until)} Si $\varphi$ et $\psi$ sont des formules propositionnelles, $(\varphi U \psi)$ est une formule propositionnelle.
	\item[] \textbf{Toujours (Globally)}. Si $\varphi$ est une formule propositionnelle, $G\varphi$ est une formule propositionnelle.
\end{itemize}

\subsubsection{Sémantique}
On pose $Q=\{q_1, \dots q_n\}$ un ensemble d'états  Pour les formules LTL, les modèles sont des couples $(p, l)$ où $p \in Q^\omega$ et $l : Q \to 2^{AP}$, $l$ nous indique ainsi quels atomes sont vraies  pour chaque états. \\
Les formules sont interprétés sur une position $i \geq 0$ le long d'une exécution étiqueté $(p, l)$. \\
On note ainsi $p, l, i \models \varphi$ le fait que $\varphi$ est vraie en $i$ le long de $(p, l)$, de plus on définit l'équivalence $\equiv$ en posant: $\varphi \equiv \psi \textrm{ si } [p,l,i \models \varphi \Leftrightarrow p,l,i \models \psi]$
\begin{itemize}
	\item[] $p, l, i \models v \Leftrightarrow v \in l(p(i))$ où $v \in AP$
	\item[] $p,l,i \not \models \bot$
	\item[] $p, l, i \models \varphi \land \psi \Leftrightarrow [(p,l,i \models \varphi) \textrm{ et } (p,l,i \models \psi)]$
	\item[] $p,l,i \models \varphi \lor \psi \Leftrightarrow [(p,l,i \models \varphi)\textrm{ ou } (p,l,i \models \psi)]$
	\item[] $p,l,i \models \lnot \varphi \Leftrightarrow p,l,i \not \models \varphi$
	\item[] $p,l,i \models X\varphi \Leftrightarrow p,l,i+1 \models \varphi$
	\item[] $p,l,i \models \varphi\, U \psi \Leftrightarrow [\exists j \geq i\textrm{ tel que, } p,l,i \models \psi \textrm{ et } \forall i \leq j \leq k, \:\: p,l,k\models \varphi]$
	\item[] $\top = \lnot \bot$
	\item[] $F\varphi = \top U \varphi$
	\item[] $G\varphi = \lnot F \lnot \varphi$
	\item[] $(\varphi \to \psi) = (\lnot \psi \lor \varphi)$
\end{itemize}

\paragraph{Représentations}
\begin{itemize}
	
	\item[] $\varphi U \psi$ \\
	\shorthandoff{:}
	\begin{tikzpicture}[scale=1]
		\draw[->] (0,0) -- (10.5,0) node[right] {};
		\foreach \x in {0,...,4} {\draw (\x,0.1cm) -- (\x,-0.1cm) node[below] {$\phantom{-}\strut$};}
		\foreach \x in {0,...,4} {\draw (\x, 0.1cm) -- (\x, -0.1cm) node[above] {$\varphi \strut$};}
		\draw (0,0) -- (0,0) node[below]{$i \phantom{-}\strut$}; 
		\draw (5,0) -- (5,0) node [above] {$\phantom{-}\dots \strut$};
		\draw (8,0.1cm) -- (8,-0.1cm) node [above] {$\psi \strut$};
		\draw (8.2,0) node [below] {$j \phantom{-} \strut$};
		\begin{scope}
			\clip (-2,2) rectangle (2,2);
		\end{scope}
	\end{tikzpicture}\shorthandon{:}\\
	\item[] 
\end{itemize}

\begin{prop}
	\leavevmode 
	\begin{enumerate}
		\item $p,l,i \models \top$
		\item $p,l,i \models F\varphi \Leftrightarrow p,l,i \models [\exists j \geq i \textrm{ tel que } p,l,j \models \varphi]$
		\item $p,l,i \models G\varphi \Leftrightarrow p,l,i \models [\forall j \geq i \textrm{, on a, } p,l,j \models \varphi]$
	\end{enumerate}
\end{prop}

\begin{dem}
	\leavevmode
	\begin{enumerate}
		\item Trivial
		\item 
		\begin{align*}
			p,l,i \models F\varphi &\Leftrightarrow p,l,i \models \top U \varphi \\
			&\Leftrightarrow p,l,i \models [\exists j \geq i \textrm{ tel que } p,l,j \models \varphi \textrm{ et } \forall i \leq j \leq k, \:\: p,l,k\models \top] \\
			&\Leftrightarrow p,l,i \models [\exists j \geq i \text{ tel que } p,l,j \models \varphi]
		\end{align*}
		\item 
		\begin{align*}
			p,l,i \models G \varphi &\Leftrightarrow p,l,i \models \lnot F \lnot \varphi \\
			&\Leftrightarrow p,l,i \not \models F \lnot \varphi \\
			&\Leftrightarrow p,l,i \not \models [\exists j \geq i \textrm{ tel que } p,l,j \models \lnot \varphi] \\
			&\Leftrightarrow p,l,i \not \models [\exists j \geq i \textrm{ tel que } p,l,j \not \models \varphi] \\
			&\Leftrightarrow p,l,i \models [\forall j \geq i \textrm{ on a } p,l,j \models \varphi]
		\end{align*}
	\end{enumerate}
\end{dem}

\begin{ex} 
	\leavevmode \newline
	$a, b \in AP$
	\begin{itemize}
		\item $GFa$: (toujours(futur $a$)) ce qui signifie il y a une infinité de positions où $a$ est vrai.
		\item $aU(Gb)$: $a$ est vrai tant que $b$ est faux, dès que $a$ est faux, $b$ est toujours vrai par la suite
		\item $(a\lor b ) U a \equiv G(a \lor b)$ car la première formule signifie on a $a$ dès qu'on à pas $a\lor b$ donc on doit toujours avoir $a \lor b$
	\end{itemize}
\end{ex}
Les propriétés sur les opérateurs de la logique usuel reste vrais dans la logique temporelle. On peut ajouter des propriétés sur les opérateurs de la logiques temporelle.
\begin{prop} 
	\leavevmode 
	\begin{enumerate}
		% Negation:
		\item $\lnot (X \varphi) \equiv X(\lnot \varphi)$
		\item $\lnot (G \varphi) \equiv F(\lnot \varphi)$
		\item $\lnot (F \varphi) \equiv G(\lnot \varphi)$
		
		%Distributivité
		\item $X (\varphi \lor \psi) \equiv (X \varphi) \lor (X \psi)$
		\item $X (\varphi \land \psi) \equiv (X \varphi) \land (X \psi)$
		\item $X (\varphi U \psi) \equiv (X \varphi) U (X \psi)$
		\item $F (\varphi \lor \psi) \equiv (F \varphi) \lor (F \psi)$
		\item $G (\varphi \land \psi) \equiv (G \varphi) \land (G \psi)$
		\item $\xi U (\varphi \lor \psi) \equiv (\xi U \varphi) \lor (\xi U \psi)$
		\item $(\varphi \land \psi) U \xi \equiv (\varphi U \xi) \land (\psi U \xi)$
		
		%Autres
		\item $F \varphi \equiv FF\varphi$
		\item $G \varphi \equiv GG\varphi$
		\item $\varphi U \psi \equiv \varphi U (\varphi U \psi)$
		\item $\psi \lor (\varphi \land X(\varphi U \psi)) \equiv \varphi U \psi$
		\item $G \varphi \equiv \varphi \land X(G \varphi)$
		\item $F \varphi \equiv \varphi \lor X(F\varphi)$
	\end{enumerate}
\end{prop}

\begin{dem}
	\leavevmode 
	\begin{enumerate}
		\item[2.] 
		\begin{align*}
			 p,l,i \models \lnot (G \varphi) &\Leftrightarrow p,l,i \not \models G \varphi \\
			 &\Leftrightarrow \lnot (\forall j \geq i\textrm{ tel que } p,l,j \models \varphi) \\
			 &\Leftrightarrow \exists j \geq i \textrm{ tel que } p,l,j \not \models \varphi \\
			 &\Leftrightarrow \exists j \geq i \textrm{ tel que } p,l,j \models \lnot \varphi \\
			 &\Leftrightarrow p,l,i \models F (\lnot \varphi)
		\end{align*}	
		
		\item[] Toutes les preuves reposent sur ce type de démonstration, on laisse les autres en exercices.
	\end{enumerate}
\end{dem}



\section{Automate de Büchi}
Les automates de Büchi sont un type particulier d'automate sur les mots infinis.
Les automates sur les mots infinis (ou $\omega$-automates) sont des automates finis qui acceptent des mots infinis.

\begin{defi}[Automate de Büchi]
  Un automate de Büchi est un quintuplet $\mathcal{A}=(\Sigma, Q, Q_I, \Delta, \mathscr{F})$ où :
  \begin{itemize}
  \item $\Sigma$ est un ensemble fini appelé alphabet de $\mathcal{A}$.
  \item $Q$ est un ensemble fini. Les éléments de $Q$ sont les états de $\mathcal{A}$.
  \item $Q_I \subseteq Q$ est l'ensemble des états initiaux.
  \item $\Delta \subset Q \times \Sigma \times Q$ est l'ensemble des transitions.
  \item $\mathscr{F} \subseteq Q$ est l'ensemble des états finaux (ou états acceptants).
    Un mot est accepté s'il passe une infinité de fois par au moins un état de $\mathscr{F}$.
  \end{itemize}

  Plus formellement, un mot est accepté par $\mathcal{A}$ si pour son exécution $\rho$ on a $Etats_{\#\infty}(\rho) \cap \mathscr{F} \neq \varnothing$, où :
  \begin{itemize}
  \item $Etats_{\#\infty}(\rho)$ est l'ensemble des états apparaissants une infinité de fois dans $\rho$
  \item Une exécution est définie ci-dessous
  \end{itemize}
\end{defi}

\begin{defi}[Exécution]
  Une exécution (ou un chemin ou un calcul) est une suite infinie de transitions consécutives : $\rho = (q_0,a_0,q_1)(q_1,a_1,q_2)\dots$.
\end{defi}

\begin{defi}[Trace]
  La trace (aussi appelée étiquette) d'une exécution est la suite des lettres, donc un mot.
  Si on a pour exécution $\rho = (q_0,a_0,q_1)(q_1,a_1,q_2)\dots$ alors la trace de $\rho$ est le mot $a_0a_1\dots$.
\end{defi}

\begin{ex}
  Soit $\mathcal{A}=(\{a,b\}, \{q_0, q_1\}, \{q_0\}, \Delta, \{q_1\})$ un automate de Büchi.
  L'ensemble des transitions $\Delta$ est donné dans la figure.
  \begin{figure}[h]
    \centering
    \begin{tikzpicture}[->, >=stealth, node distance=3cm, initial text=$ $, on grid]
      \node[state, initial] (q0) {$q_0$};
      \node[state, accepting, right of=q0] (q1) {$q_1$};
      \draw (q0) edge[bend left, above] node{a} (q1)
      (q1) edge[bend left, below] node{b} (q0)
      (q1) edge[loop above] node{a} (q1);
    \end{tikzpicture}    
    \caption{Automate de Büchi}
  \end{figure}
  
  Cet automate reconnaît le mot $aaa\dots$ car dans sa trace $q_0q_1q_1\dots$ l'état $q_1$ apparaît une infinité de fois.
  En fait, le langage reconnu (ou accepté) est $aa^\omega | a(a^*ba)^\omega$.
\end{ex}

Les automates de Büchi généralisés sont une variante des automates de Büchi.
La différence se situe sur la condition d'acceptation.
\begin{defi}[Automate de Büchi généralisé]
Un automate de Büchi généralisé est un quintuplet $\mathcal{A}=(\Sigma, Q, Q_I, \Delta, \mathscr{F})$ où :
  \begin{itemize}
  \item $\Sigma, Q, Q_I, \Delta$ sont comme précédemment.
  \item $\mathscr{F} \subseteq \mathcal{P}(Q)$ est la condition d'acceptation.
    $\mathscr{F}$ est un ensemble d'ensembles finaux.
  \end{itemize}

  Un chemin $c$ est accepté par $\mathcal{A}$ si pour tout $F \in \mathscr{F}$ il existe $S \in Etats_{\#\infty}(c)$ tel que $S \in F$.
  Autrement dit, $\mathcal{A}$ reconnaît $c$ si on passe infiniment souvent par un des états de chaque $F \in \mathscr{F}$.
\end{defi}

\subsection{Traduction de formule LTL en automate de Büchi}
On souhaite ``traduire'' une formule LTL en un automate de Büchi. Plus précisèment, on veut construire un automate qui reconnait les modèles de $\varphi$.

\begin{defi}
  On note $SubF(\varphi)$ l'ensemble des sous formules de $\varphi$ et leur négation.  
\end{defi}

\begin{ex}
  Si $\varphi = a U b$ alors $SubF(\varphi) = \{ a, \lnot a, b, \lnot b, a U b, \lnot(a U b)\}$.
\end{ex}

\begin{defi}[Sous-ensemble cohérent]
  Soit $q \in 2^{SubF(\varphi)}$. On dit que $q$ est cohérent si $q$ vérifie toutes les conditions suivantes :
  \begin{enumerate}[(i)]
  \item Si $\psi_1 \land \psi_2 \in q$ alors $\psi_1 \in q$ et $\psi_2 \in q$.
  \item Si $\psi_1 \lor \psi_2 \in q$ alors $\psi_1 \in q$ ou $\psi_2 \in q$.
  \item $\psi \in q \iff \lnot \psi \not\in q$.
  \end{enumerate}
\end{defi}

\begin{rmq}
  En utilisant les lois de Morgan, on en déduit aussi que :
  \begin{enumerate}[(i)]
  \item Si $\lnot (\psi_1 \land \psi_2) \in q$ alors $\psi_1 \not \in q$ ou $\psi_2 \not \in q$.
  \item Si $\lnot (\psi_1 \lor \psi_2) \in q$ alors $\psi_1 \not \in q$ et $\psi_2 \not \in q$.
  \end{enumerate}
\end{rmq}


\begin{defi}[Sous-ensemble maximal]
  Soit $q \in 2^{SubF(\varphi)}$. On dit que $q$ est maximal si pour tout $\psi \in SubF(\varphi)$ on a soit $\psi \in q$ soit $\lnot \psi \in q$.  
\end{defi}

\begin{defi}[Sous-ensemble conforme à la sémantique de LTL]
  Soit $q \in 2^{SubF(\varphi)}$. On dit que $q$ est conforme à la sémantique de LTL
  \begin{enumerate}[(i)]
  \item Si $\psi_1 U \psi_2 \in q$ alors on a soit $\psi_1 \in q$ soit $\psi_2 \in q$.
  \item Si $\psi_1 U \psi_2 \in SubF(\varphi)$, alors si $\psi_2 \in q$, $\psi_1 U \psi_2 \in q$.
  \end{enumerate}
\end{defi}

\begin{ex}
  Soit $\varphi = a U (Xb)$ alors
  \[
    SubF(\varphi) = \{a, \lnot a, b, \lnot b, Xb, \lnot (Xb), a U (Xb), \lnot (aU(Xb))\}
  \]
  \begin{enumerate}
  \item $q_1 = \{\lnot a, b, Xb, a U (Xb)\}$ est un sous-ensemble cohérent, maximal et conforme à la sémantique de LTL.
  \item ...
  \end{enumerate}
\end{ex}

\begin{thm}
  Soit $AP$ l'ensemble des propositions atomiques et $\varphi$ une formule LTL sur $AP$, alors $\mathcal{L}(\mathcal{A}_\varphi) = mod(\varphi)$
  où $\mathcal{A}_\varphi$ est l'automate de Büchi généralisé donné ci-dessous.

  % \noindent
  On définit $\mathcal{A}_\varphi = (2^{AP}, Q, Q_I, \Delta, \mathscr{F})$ où :
  \begin{itemize}
  \item $Q \subseteq 2^{SubF(\varphi)}$ contient tout les sous-ensembles de $SubF(\varphi)$ qui sont cohérents, maximaux et conformes à la sémantique de LTL.
  \item $Q_I = \{ q \subseteq SubF(\varphi) | \varphi \in q \}$. Autrement dit, tous les états contenant exactement notre formule de départ $\varphi$ sont des états initiaux.
  \item $\Delta$ est l'ensemble des transitions $(q, a, q')$ avec $q, q' \subseteq SubF(\varphi)$ et $a \in 2^{AP}$ vérifiant :
    \begin{itemize}
    \item $\bot \not \in q$
    \item $\forall p \in AP \quad p \in q \iff p \in a$ (i.e. $a$ possède toutes les propositions atomiques de $q$)
    \item Si $\psi_1 \lor \psi_2 \in q$ alors $\psi_1 \in q'$ ou $\psi_2 \in q'$
    \item Si $\psi_1 \land \psi_2 \in q$ alors $\psi_1 \in q'$ et $\psi_2 \in q'$
    \item Si $X\psi \in q$ alors $\psi \in q'$
    \item Si $\psi_1 U \psi_2 \in q$ alors $\psi_2 \in q'$ ou $\{\psi_1, \psi_1 U \psi_2\} \subseteq q'$
    \item Si $\lnot \psi \in q$ alors ...
    \end{itemize}
  \item $\mathscr{F} = \{F_{\psi_1 U \psi_2} | \psi_1 U \psi_2 \in SubF(\varphi)\}$ où
    \[
      F_{\psi_1 U \psi_2} = \{q \in Q | \psi_1 U \psi_2 \not \in q \lor \psi_2\in q \}
    \]
  \end{itemize}
\end{thm}

\begin{proof}
  ...
\end{proof}


\end{document}